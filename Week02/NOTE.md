学习笔记

    本周主要学习了哈希表、集合、树、二叉树、二叉搜索树
    
    哈希表（Hash table）也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。 这个映射函数叫做散列函数，存放记录的数组叫做哈希表（散列表）。 哈希碰撞：不同的值，经过哈希换数之后会得到一个相同的值。 解决哈希碰撞的办法：在发生碰撞的位置放入一个链表，也就是拉链式解决冲突法。将相同哈希值的位置存放对应元素的列表，哈希函数的查询时间复杂度是O(1)的，增加、删除、查询时间复杂度均为O(1),最坏情况下为O(n) java中对应的就是Map(key-value对，key不重复)和Set(不重复元素的集合)
    
    HashMap实现原理
    
    HashMap基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。
    
    两个重要的参数:
    Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket填充的数目（即hashmap中元素的个数）大于capacity*load factor时就需要调整buckets的数目为当前的2倍。
    
    HashMap的主干是一个Node数组。java8新加了红黑树。Node是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。 简单来说，HashMap由数组+链表+红黑树实现的。 HashMap使用哈希表来存储。
    
    HashMap的数组长度一定是2的次幂。
    
    HashMap线程不安全,put的时候多线程可能会导致数据不一致；自动扩容时可能出现多个线程同时修改链表结构。
    
    二叉搜索树（Binary Search Tree）：
    它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势
    
   